import { Provider } from '@ethersproject/providers';
import { ClaimData, ClaimObject, ClaimStatus, ClaimTopic } from './Claim.interface';
import { SignerModuleInterface } from '../core/SignerModule';
import { HexString } from '../core/utils/Utils';
export declare class Claim implements ClaimObject {
    address?: string;
    data?: string;
    hash?: string;
    id?: string;
    issuanceDate?: Date;
    emissionDate?: Date;
    issuer?: string;
    privateData?: object;
    publicData?: object;
    scheme?: number;
    signature?: string;
    status?: ClaimStatus;
    topic?: number;
    uri?: string;
    /**
       * Generate the hash of a claim using the provided data, use this method when using a JSON scheme with public and private data.
       * This hash should be put in the `data` field of the claim.
       * @param topic
       * @param emissionDate
       * @param publicData
       * @param privateData
       */
    static generateHash(topic: ClaimTopic | number, emissionDate: Date, publicData: object, privateData: object): string;
    /**
     * Generate the blockchain hash of the claim. This is the hash that has to be sign by the claim issuer.
     * @param address
     * @param topic
     * @param data
     */
    static generateBlockchainHash(address: string, topic: number, data: string): string;
    static generateClaimID(issuer: string, topic: ClaimTopic | number): string;
    /**
     * Generate the blockchain hash of a claim and signs it with the provided signer or the default signer of the SDK.
     * @param topic
     * @param address
     * @param data
     * @param [signer]
     * @returns Claim signature.
     */
    static sign(topic: ClaimTopic | number, address: string, data: HexString, signer: SignerModuleInterface): Promise<string>;
    /**
       * Verify the signature of a claim.
       * The standard signature of a claim is the keccak256 hash of (identityAddress, topic, data) prefixed and signed.
       * The data argument is exactly the content of the data claim field stored in blockchain (caution to hex padding).
       * Data is expected to be an hexString.
       * Using the IdentitySDK, call `IdentitySDK.utils.toHex('data')`.
       * Using web3utils, call `web3utils.asciiToHex('data')`.
       * Using ethersjs, call `Ethers.utils.hexlify(Ethers.utils.toUtf8Bytes('data'))`
       * @param signingKey
       * @param topic
       * @param address Address of identity contract.
       * @param data
       * @param signature
       */
    static verifySignature(signingKey: string, topic: ClaimTopic | number, address: string, data: string, signature: string): Promise<boolean>;
    /**
       * Create a new Claim Object from a ClaimData (got from BlockChain Identity Contract).
       * Use #.createFromURI() to fetch from an URI.
       * @param claim
       */
    constructor(claim?: ClaimData);
    /**
       * Generate the hash of the claim data if it was populated with private data.
       * If all data are not provided as arguments, data fromm the Claim object will be used.
       * Note that to verify a claim complete data, you will need to have access to its private data.
       * Use the .populate() method to fetch all the public and private data if available.
       * @param topic
       * @param emissionDate
       * @param publicData
       * @param privateData
       */
    generateHash(topic?: ClaimTopic | number, emissionDate?: Date, publicData?: object, privateData?: object): string;
    /**
     * Sign the claim.
     * It will update the signature property of the claim. The signature can only be generated for a claim that as a topic, an address and data.
     * @param signer Signer module to use. If null, use default signer of SDK.
     */
    sign(signer: SignerModuleInterface): Promise<string>;
    /**
     * Verify the validity of a claim against the Claim Issuer Contract.
     * @param provider Provider instance to fetch blockchain data.
     * @return true if the claim is declared valid by the Claim Issuer, false otherwise.
     */
    verifyValidity(provider: Provider): Promise<boolean>;
}
