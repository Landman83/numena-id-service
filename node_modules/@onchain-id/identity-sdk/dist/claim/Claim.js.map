{"version":3,"file":"Claim.js","sourceRoot":"","sources":["../../src/claim/Claim.ts"],"names":[],"mappings":"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","sourcesContent":["import { Provider } from '@ethersproject/providers';\nimport { arrayify, sha256, toUtf8Bytes, verifyMessage } from 'ethers/lib/utils';\nimport * as OnchainID from '@onchain-id/solidity';\n\nimport {\n  ClaimData,\n  ClaimObject,\n  ClaimStatus,\n  ClaimTopic\n} from './Claim.interface';\nimport { SignerModule, SignerModuleInterface } from '../core/SignerModule';\nimport { Contract } from 'ethers';\nimport { encodeAndHash, HexString, isHexString } from '../core/utils/Utils';\nimport { InvalidProviderError } from '../core/errors/Errors';\n\nexport class Claim implements ClaimObject {\n  public address?: string;\n  public data?: string;\n  public hash?: string;\n  public id?: string;\n  public issuanceDate?: Date;\n  public emissionDate?: Date;\n  public issuer?: string;\n  public privateData?: object;\n  public publicData?: object;\n  public scheme?: number;\n  public signature?: string;\n  public status?: ClaimStatus;\n  public topic?: number;\n  public uri?: string;\n\n  /**\n     * Generate the hash of a claim using the provided data, use this method when using a JSON scheme with public and private data.\n     * This hash should be put in the `data` field of the claim.\n     * @param topic\n     * @param emissionDate\n     * @param publicData\n     * @param privateData\n     */\n  public static generateHash(topic: ClaimTopic | number, emissionDate: Date, publicData: object, privateData: object): string {\n    if (publicData && privateData && emissionDate && topic) {\n      return sha256(toUtf8Bytes(JSON.stringify({ topic, emissionDate, privateData, publicData })));\n    } else {\n      throw new Error(\"Can't generate the Claim Hash because some data is missing.\");\n    }\n  }\n\n  /**\n   * Generate the blockchain hash of the claim. This is the hash that has to be sign by the claim issuer.\n   * @param address\n   * @param topic\n   * @param data\n   */\n  public static generateBlockchainHash(address: string, topic: number, data: string): string {\n    return encodeAndHash(['address', 'uint256', 'bytes'], [address, topic, data]);\n  }\n\n  public static generateClaimID(issuer: string, topic: ClaimTopic | number): string {\n    return encodeAndHash(['address', 'uint256'], [issuer, topic]);\n  }\n\n  /**\n   * Generate the blockchain hash of a claim and signs it with the provided signer or the default signer of the SDK.\n   * @param topic\n   * @param address\n   * @param data\n   * @param [signer]\n   * @returns Claim signature.\n   */\n  public static async sign(topic: ClaimTopic | number, address: string, data: HexString, signer: SignerModuleInterface): Promise<string> {\n    if (!SignerModule.isSignerModule(signer)) {\n      throw new InvalidProviderError('A signer is required to generate a claim signature.');\n    }\n\n    if (!isHexString(data)) {\n      throw new Error('Claim data to sign must be a valid hex string.');\n    }\n\n    const claimHash = Claim.generateBlockchainHash(address, topic, data);\n    return signer.signMessage(arrayify(claimHash));\n  }\n\n  /**\n     * Verify the signature of a claim.\n     * The standard signature of a claim is the keccak256 hash of (identityAddress, topic, data) prefixed and signed.\n     * The data argument is exactly the content of the data claim field stored in blockchain (caution to hex padding).\n     * Data is expected to be an hexString.\n     * Using the IdentitySDK, call `IdentitySDK.utils.toHex('data')`.\n     * Using web3utils, call `web3utils.asciiToHex('data')`.\n     * Using ethersjs, call `Ethers.utils.hexlify(Ethers.utils.toUtf8Bytes('data'))`\n     * @param signingKey\n     * @param topic\n     * @param address Address of identity contract.\n     * @param data\n     * @param signature\n     */\n  public static async verifySignature(signingKey: string, topic: ClaimTopic | number, address: string, data: string, signature: string): Promise<boolean> {\n    if (!isHexString(data)) {\n      throw new Error('Claim data to sign must be a valid hex string.');\n    }\n    const claimHash = Claim.generateBlockchainHash(address, topic, data);\n\n    try {\n      const signerAddress = await verifyMessage(arrayify(claimHash), signature);\n\n      return signerAddress === signingKey;\n    } catch (err) {\n      return false;\n    }\n  }\n\n  /**\n     * Create a new Claim Object from a ClaimData (got from BlockChain Identity Contract).\n     * Use #.createFromURI() to fetch from an URI.\n     * @param claim\n     */\n  public constructor(claim?: ClaimData) {\n    if (claim) {\n      Object.assign(this, claim);\n    }\n  }\n\n  /**\n     * Generate the hash of the claim data if it was populated with private data.\n     * If all data are not provided as arguments, data fromm the Claim object will be used.\n     * Note that to verify a claim complete data, you will need to have access to its private data.\n     * Use the .populate() method to fetch all the public and private data if available.\n     * @param topic\n     * @param emissionDate\n     * @param publicData\n     * @param privateData\n     */\n  public generateHash(topic?: ClaimTopic | number, emissionDate?: Date, publicData?: object, privateData?: object): string {\n    if (publicData && privateData && emissionDate && topic) {\n      return Claim.generateHash(topic, emissionDate, publicData, privateData);\n    } else {\n      if (!this.publicData || !this.privateData || !this.emissionDate) {\n        throw new Error(\"Can't generate the Claim Hash because some data is missing. Call .populate() first to retrieve data from the Claim Issuer.\");\n      }\n      return this.generateHash(this.topic, this.emissionDate, this.publicData, this.privateData);\n    }\n  }\n\n  /**\n   * Sign the claim.\n   * It will update the signature property of the claim. The signature can only be generated for a claim that as a topic, an address and data.\n   * @param signer Signer module to use. If null, use default signer of SDK.\n   */\n  public async sign(signer: SignerModuleInterface): Promise<string> {\n    if (!this.topic) {\n      throw new Error('Claim has no topic defined, thus it cannot be signed.');\n    }\n\n    if (!this.address) {\n      throw new Error('Claim has no address defined, thus it cannot be signed.');\n    }\n\n    if (!this.data) {\n      throw new Error('Claim has no data defined, thus it cannot be signed.');\n    }\n\n    const signature = await Claim.sign(this.topic, this.address, this.data, signer);\n\n    this.signature = signature;\n\n    return signature;\n  }\n\n  /**\n   * Verify the validity of a claim against the Claim Issuer Contract.\n   * @param provider Provider instance to fetch blockchain data.\n   * @return true if the claim is declared valid by the Claim Issuer, false otherwise.\n   */\n  public async verifyValidity(provider: Provider): Promise<boolean> {\n    if (!this.topic || !this.address || !this.signature) {\n      throw new Error(`Claim is not complete and thus cannot be verified.`);\n    }\n    if (!this.issuer) {\n      throw new Error('A claim that has no issuer address cannot be verified.');\n    }\n\n    const claimIssuerInstance = new Contract(this.issuer, OnchainID.interfaces.IClaimIssuer.abi, provider);\n\n    return claimIssuerInstance.isClaimValid(this.address, this.topic, this.signature, this.data);\n  }\n}\n"]}