import { BigNumber, Signer, Contract } from 'ethers';
import { Provider, TransactionResponse } from '@ethersproject/providers';
import { EventFragment, FunctionFragment, Interface } from 'ethers/lib/utils';
import { ClaimData, ClaimScheme, ClaimTopic } from '../claim/Claim.interface';
import { Key, KeyPurpose, KeyType } from './Key.interface';
import { IdentityInterface } from './identity.interface';
import { BlockchainOptions } from '../core/utils/blockchain-options';
export declare class KeyPurposeAlreadyRegisteredError extends Error {
    constructor({ message }?: {
        message?: string;
    });
}
export declare class KeyPurposeNotRegisteredError extends Error {
    constructor({ message }?: {
        message?: string;
    });
}
export declare class InvalidKeyError extends Error {
    constructor({ message }?: {
        message?: string;
    });
}
export declare class InvalidClaimError extends Error {
    constructor({ message }?: {
        message?: string;
    });
}
export declare class NonExistingClaimError extends Error {
    constructor({ message }?: {
        message?: string;
    });
}
export declare class Identity implements IdentityInterface {
    keyHolderInstance?: Contract;
    claimHolderInstance?: Contract;
    address?: string;
    provider?: Provider | Signer;
    private deploymentContract?;
    /**
     * Instantiate a new Identity with the provided address or ENS string that will be resolved.
     * @param addressOrENS Must be a valid Ethereum address, checksumed, all lower-case or all uppercase.
     * @param options
     * @params options.provider If provided, the identity will use this provider for all blockchain operation (unless override) instead of the SDK default provider.
     */
    static at(addressOrENS: string, options?: BlockchainOptions): Promise<Identity>;
    /**
     * Compute the address an ONCHAINID deployed using a Factory/Gateway would have.
     * @param factory The address of the factory contract (this is not the address of the Gateway contract)
     * @param unprefixedSalt The salt specified when requesting the deployment, usually the address of the identity owner.
     * @param implementationAuthority The address of the implementation authority contract used by the Factory.
     */
    static computeDeploymentAddress({ factory, unprefixedSalt, implementationAuthority }: {
        factory: string;
        unprefixedSalt: string;
        implementationAuthority: string;
    }): string;
    /**
     * Deploy a new Identity, and return the Identity object.
     * The signer will pay for the deployment, and will be added in the MANAGEMENT keys.
     * If not given, the Signer will use the default provider from the SDK if it is defined and is a Signer.
     * Note that the identity will be returned with the provided Signer, thus management operation can be chained.
     * @param config - Configuration of the identity to deploy.
     * @param config.managementKey - Ethereum address to set as the initial management key.
     * @param config.implementationAuthority - Ethereum address of the implementation authority to use.
     * @param options
     * @example Usually called with `identity.deployed()`:
     * ```typescript
     * const identity = await Identity.deployNew();
     * await identity.deployed();
     * ```
     */
    static deployNew(config: {
        managementKey: string;
        implementationAuthority: string;
    }, options: BlockchainOptions): Promise<Identity>;
    /**
     * Deploy a new Identity for a given wallet and a specific salt, and return the Identity object, using an ONCHAINID
     * Gateway. To deploy an identity using this method, the gatewa requires a signature from an approved signer that
     * contains the salt and the address of the identity owner (see specifications).
     * The signer will pay for the deployment.
     * If not given, the Signer will use the default provider from the SDK if it is defined and is a Signer.
     * Note that the identity will be returned with the provided Signer, thus management operation can be chained.
     * @param config - Configuration of the identity to deploy.
     * @param config.gateway - address of the gateway to use
     * @param config.identityOwner - address of the identity owner
     * @param config.salt - address of the factory to deploy a proxy identity.
     * @param config.signature - signature of salt + identityOwner + expiry (see specifications)
     * @param config.signatureExpiry - the block timestamp where the signature will expire (in seconds and as a BigNumber)
     * @param options
     * @param options.signer - the signer to use to sign and send the transaction
     * @example Usually called with `identity.deployed()`:
     * ```typescript
     * const identity = await Identity.deployUsingGatewayWithSalt({
     *   gateway: '0x...',
     *   identityOwner: '0x..',
     *   salt: 'some-salt',
     *   signature: '0x...',
     *   signatureExpiry: BigNumber.from('1689583125'),
     * });
     * await identity.deployed();
     * ```
     */
    static deployUsingGatewayWithSalt(config: {
        gateway: string;
        identityOwner: string;
        salt: string;
        signature: string;
        signatureExpiry: BigNumber;
    }, options: BlockchainOptions): Promise<TransactionResponse>;
    /**
     * Deploy a new Identity for a given wallet and a specific salt, and return the Identity object, using an ONCHAINID
     * Gateway. To deploy an identity using this method, the gateway requires a signature from an approved signer that
     * contains the salt and the address of the identity owner and the list of management keys (see specifications).
     * The signer will pay for the deployment.
     * If not given, the Signer will use the default provider from the SDK if it is defined and is a Signer.
     * Note that the identity will be returned with the provided Signer, thus management operation can be chained.
     * @param config - Configuration of the identity to deploy.
     * @param config.gateway - address of the gateway to use
     * @param config.identityOwner - address of the identity owner
     * @param config.salt - address of the factory to deploy a proxy identity.
     * @param config.managementKeys - list of management keys to add to the identity
     * @param config.signature - signature of salt + identityOwner + expiry (see specifications)
     * @param config.signatureExpiry - the block timestamp where the signature will expire (in seconds and as a BigNumber)
     * @param options
     * @param options.signer - the signer to use to sign and send the transaction
     * @example Usually called with `identity.deployed()`:
     * ```typescript
     * const identity = await Identity.deployUsingGatewayWithSalt({
     *   gateway: '0x...',
     *   identityOwner: '0x..',
     *   salt: 'some-salt',
     *   managementKeys: [IdentitySDK.utils.encodeAndHash(['address'], ['0x...'])],
     *   signature: '0x...',
     *   signatureExpiry: BigNumber.from('1689583125'),
     * });
     * await identity.deployed();
     * ```
     */
    static deployUsingGatewayWithSaltAndManagementKeys(config: {
        gateway: string;
        identityOwner: string;
        salt: string;
        managementKeys: string[];
        signature: string;
        signatureExpiry: BigNumber;
    }, options: BlockchainOptions): Promise<TransactionResponse>;
    /**
     * Deploy a new Identity, and return the Identity object, using an ONCHAINID Gateway. This method only deploys
     * an identity for the wallet that signed the transaction.
     * The signer will pay for the deployment.
     * If not given, the Signer will use the default provider from the SDK if it is defined and is a Signer.
     * Note that the identity will be returned with the provided Signer, thus management operation can be chained.
     * @param config - Configuration of the identity to deploy.
     * @param config.gateway - address of the gateway to use
     * @param config.identityOwner - address of the identity owner, must be the address of the signer
     * @param options
     * @param options.signer - the signer to use to sign and send the transaction
     * @example Usually called with `identity.deployed()`:
     * ```typescript
     * const identity = await Identity.deployUsingGatewayWithSalt({
     *   gateway: '0x...',
     *   identityOwner: '0x..',
     * });
     * await identity.deployed();
     * ```
     */
    static deployUsingGatewayForWallet(config: {
        gateway: string;
        identityOwner: string;
    }, options: BlockchainOptions): Promise<TransactionResponse>;
    /**
     * Instantiate an Identity.
     * @param address A valid Ethereum address (not an ENS, use `Identity#at(ens)`.).
     * @param provider Override the default provider of SDK, and use for all operation of this Identity.
     */
    constructor(address: string, provider?: Provider | Signer);
    /**
     * Add a claim to an Identity.
     * The signature must have been signed with a keypair having the public key in the CLAIM keys of Identity.
     * @param topic
     * @param scheme
     * @param issuer
     * @param signature
     * @param data
     * @param uri
     * @param [options]
     */
    addClaim(topic: ClaimTopic, scheme: ClaimScheme, issuer: string, signature: string, data: string, uri: string, options?: BlockchainOptions): Promise<TransactionResponse>;
    /**
     * Add a Key to an Identity.
     * The Signer must have a MANAGEMENT key in the Identity.
     * @param key Must be a valid byte32 hex string (pass the keccak256 hash of the key string encoded (abi.encode)).
     * @param purpose Must be an integer. It is recommended to use the standard KeyPurpose enum.
     * @param type Must be a an integer. It is recommended to use the standard KeyType enum.
     * @param [options]
     */
    addKey(key: string, purpose: KeyPurpose, type: KeyType, options?: BlockchainOptions): Promise<TransactionResponse>;
    /**
     * Returns the Identity if the Identity was deployed, or awaits for the Identity to be deployed before returning it.
     *
     * @example Usually called after a `Identity.deployNew()`:
     * ```typescript
     * const identity = await Identity.deployNew();
     * await identity.deployed();
     * ```
     */
    deployed(): Promise<Identity>;
    /**
     * Get ClaimData details for an Identity.
     * @param claimId
     * @param [options]
     */
    getClaim(claimId: string, options?: BlockchainOptions): Promise<ClaimData>;
    /**
     * Get claims details for an Identity.
     * @deprecated
     * @param claimId
     * @param [options]
     */
    getClaims(claimId: string, options?: BlockchainOptions): Promise<ClaimData[]>;
    /**
     * Get Claims details by topic for an Identity.
     * @param topic
     * @param [options]
     */
    getClaimsByTopic(topic: ClaimTopic | number, options?: BlockchainOptions): Promise<ClaimData[]>;
    /**
     * Get ClaimData IDs by topic for an Identity.
     * @param topic
     * @param [options]
     */
    getClaimIdsByTopic(topic: ClaimTopic | number, options?: BlockchainOptions): Promise<string[]>;
    /**
     * Returns the deployment transaction of the Identity if it was previously created with Identity.deployNew().
     *
     * @example Can be called only after a `Identity.deployNew()`:
     * ```typescript
     * const identity = await Identity.deployNew();
     * identity.getDeployTransaction();
     * ```
     */
    getDeployTransaction(): TransactionResponse | null;
    /**
     * Get the details of a key in an Identity.
     * @param key
     * @param [options]
     */
    getKey(key: string, options?: BlockchainOptions): Promise<Key>;
    /**
     * Get the purpose of a key in an identity.
     * @param key
     * @param [options]
     */
    getKeyPurposes(key: string, options?: BlockchainOptions): Promise<KeyPurpose[]>;
    /**
     * Get the details of the keys contained in an Identity by purpose.
     * @param purpose
     * @param [options]
     */
    getKeysByPurpose(purpose: KeyPurpose, options?: BlockchainOptions): Promise<Key[]>;
    /**
     * Instantiate the Identity IdentityInterface Contract with the Identity's address.
     * @param [providerOrSigner]
     */
    instantiateClaimHolder(providerOrSigner?: Provider | Signer): Promise<Contract>;
    /**
     * Instantiate the Identity KeyHolder Contract with the Identity's address.
     * @param [providerOrSigner]
     */
    instantiateKeyHolder(providerOrSigner?: Provider | Signer): Promise<Contract>;
    /**
     * Instantiate an Identity with the given abi using the object's address.
     * @param abi
     * @param [providerOrSigner]
     */
    instantiate(abi: Array<string | FunctionFragment | EventFragment> | string | Interface, providerOrSigner?: Provider | Signer): Promise<Contract>;
    /**
     * Instantiate an Identity with the given abi at a given address.
     * @param address
     * @param abi
     * @param [providerOrSigner]
     */
    instantiateAtAddress(address: string, abi: Array<string | FunctionFragment | EventFragment> | string | Interface, providerOrSigner?: Provider | Signer): Promise<Contract>;
    /**
     * Check if a key has at least the given purpose.
     * @param key
     * @param purpose
     * @param [options]
     */
    keyHasPurpose(key: string, purpose: KeyPurpose, options?: BlockchainOptions): Promise<boolean>;
    /**
     * Remove a claim, provided the signer has the right to do so.
     * @param claimId
     * @param [options]
     */
    removeClaim(claimId: string, options?: BlockchainOptions): Promise<TransactionResponse>;
    /**
     * Remove a Key from an Identity.
     * The Signer must have a MANAGEMENT key in the Identity.
     * @param key Key must be a valid byte32 hex string.
     * @param purpose KeyPurpose must be a valid byte32 hex string.
     * @param [options]
     */
    removeKey(key: string, purpose: number, options?: BlockchainOptions): Promise<TransactionResponse>;
    /**
     * Use another provider or signer to interact with the Identity.
     * This will reset all contract instances of the identity that will need to be instantiated once again with the new provider.
     * @param providerOrSigner
     */
    useProvider(providerOrSigner: Provider | Signer): void;
    /**
     * Verify if the message was signed with a key that is authorized to perform action for this Identity.
     * @param message
     * @param signature
     * @param [options]
     */
    validateSignature(message: string, signature: string, options?: BlockchainOptions): Promise<boolean>;
    /**
     * Verify a specific claim given with full data or by ID.
     * @param claim Claim object or ID.
     * @param [options]
     */
    verifyClaim(claim: any | string, options?: BlockchainOptions): Promise<{
        valid: boolean;
        reason?: string;
    }>;
}
