{"version":3,"file":"Identity.js","sourceRoot":"","sources":["../../src/identity/Identity.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,mCAAiF;AACjF,wDAAyE;AACzE,4CAS0B;AAC1B,gEAAkD;AAGlD,mDAA2D;AAE3D,2CAAiE;AACjE,0CAAuC;AACvC,+CAAoD;AACpD,kDAAsF;AAGtF,MAAa,gCAAiC,SAAQ,KAAK;IACzD,YAAmB,EAAE,OAAO,GAAG,+CAA+C,KAA2B,EAAE;QACzG,KAAK,CAAC,OAAO,CAAC,CAAC;QACf,IAAI,CAAC,IAAI,GAAG,kCAAkC,CAAC;QAE/C,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,gCAAgC,CAAC,SAAS,CAAC,CAAC;IAC1E,CAAC;CACF;AAPD,4EAOC;AAED,MAAa,4BAA6B,SAAQ,KAAK;IACrD,YAAmB,EAAE,OAAO,GAAG,qDAAqD,KAA2B,EAAE;QAC/G,KAAK,CAAC,OAAO,CAAC,CAAC;QACf,IAAI,CAAC,IAAI,GAAG,8BAA8B,CAAC;QAE3C,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,4BAA4B,CAAC,SAAS,CAAC,CAAC;IACtE,CAAC;CACF;AAPD,oEAOC;AAED,MAAa,eAAgB,SAAQ,KAAK;IACxC,YAAmB,EAAE,OAAO,GAAG,qCAAqC,KAA2B,EAAE;QAC/F,KAAK,CAAC,OAAO,CAAC,CAAC;QACf,IAAI,CAAC,IAAI,GAAG,iBAAiB,CAAC;QAE9B,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,eAAe,CAAC,SAAS,CAAC,CAAC;IACzD,CAAC;CACF;AAPD,0CAOC;AAED,MAAa,iBAAkB,SAAQ,KAAK;IAC1C,YAAmB,EAAE,OAAO,GAAG,uCAAuC,KAA2B,EAAE;QACjG,KAAK,CAAC,OAAO,CAAC,CAAC;QACf,IAAI,CAAC,IAAI,GAAG,mBAAmB,CAAC;QAEhC,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,iBAAiB,CAAC,SAAS,CAAC,CAAC;IAC3D,CAAC;CACF;AAPD,8CAOC;AAED,MAAa,qBAAsB,SAAQ,KAAK;IAC9C,YAAmB,EAAE,OAAO,GAAG,yBAAyB,KAA2B,EAAE;QACnF,KAAK,CAAC,OAAO,CAAC,CAAC;QACf,IAAI,CAAC,IAAI,GAAG,uBAAuB,CAAC;QAEpC,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,qBAAqB,CAAC,SAAS,CAAC,CAAC;IAC/D,CAAC;CACF;AAPD,sDAOC;AAED,MAAa,QAAQ;IAQnB;;;;;OAKG;IACI,MAAM,CAAO,EAAE,CAAC,YAAoB,EAAE,OAA2B;;YACtE,IAAI,OAAe,CAAC;YAEpB,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;gBAC/B,OAAO,GAAG,IAAA,sBAAgB,EAAC,YAAY,CAAC,CAAC;aAC1C;iBAAM;gBACL,IAAI,oBAAQ,CAAC,UAAU,CAAC,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,QAAQ,CAAC,EAAE;oBAC1C,OAAO,GAAG,MAAM,IAAA,gBAAU,EAAC,YAAY,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,QAAoB,CAAC,CAAC;iBACzE;qBAAM,IAAI,eAAM,CAAC,QAAQ,CAAC,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,MAAM,CAAC,IAAI,oBAAQ,CAAC,UAAU,CAAC,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,MAAM,CAAC,QAAQ,CAAC,EAAE;oBAC5F,OAAO,GAAG,MAAM,IAAA,gBAAU,EAAC,YAAY,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,MAAM,CAAC,QAAoB,CAAC,CAAC;iBAChF;qBAAM;oBACL,MAAM,IAAI,6BAAoB,CAAC,oCAAoC,CAAC,CAAC;iBACtE;aACF;YAED,OAAO,IAAI,QAAQ,CAAC,OAAO,EAAE,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,MAAM,MAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,QAAQ,CAAA,CAAC,CAAC;QACrE,CAAC;KAAA;IAED;;;;;OAKG;IACI,MAAM,CAAC,wBAAwB,CAAC,EAAE,OAAO,EAAE,cAAc,EAAE,uBAAuB,EAAgF;QACvK,OAAO,IAAA,yBAAiB,EACtB,OAAO,EACP,IAAA,iBAAS,EACP,IAAA,mBAAW,EAAC,KAAK,GAAG,cAAc,CAAC,CACpC,EACD,IAAA,iBAAS,EACP,IAAA,cAAM,EACJ;YACE,SAAS,CAAC,SAAS,CAAC,aAAa,CAAC,QAAQ;YAC1C,uBAAe,CAAC,MAAM,CACpB,CAAC,SAAS,EAAE,SAAS,CAAC,EACtB,CAAC,uBAAuB,EAAE,OAAO,CAAC,CACnC;SACF,CACF,CACF,CACF,CAAC;IACJ,CAAC;IAED;;;;;;;;;;;;;;OAcG;IACI,MAAM,CAAO,SAAS,CAAC,MAAmE,EAAE,OAA0B;;;YAC3H,IAAI,CAAC,eAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;gBACpC,MAAM,IAAI,6BAAoB,CAAC,wCAAwC,CAAC,CAAC;aAC1E;YAED,IAAG,CAAC,IAAA,mBAAW,EAAC,MAAM,CAAC,aAAa,CAAC,EAAE;gBACrC,MAAM,IAAI,eAAe,EAAE,CAAC;aAC7B;YAED,MAAM,QAAQ,GAAG,MAAM,IAAI,wBAAe,CAAC,SAAS,CAAC,SAAS,CAAC,aAAa,CAAC,GAAG,EAAE,SAAS,CAAC,SAAS,CAAC,aAAa,CAAC,QAAQ,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,MAAM,CAAC,CAAC,MAAM,CACnJ,MAAM,CAAC,uBAAuB,EAC9B,MAAM,CAAC,aAAa,EACpB,MAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,SAAS,mCAAI,EAAE,CACzB,CAAC;YAEF,MAAM,QAAQ,GAAG,IAAI,QAAQ,CAAC,QAAQ,CAAC,OAAO,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,MAAM,CAAC,CAAC;YACjE,QAAQ,CAAC,kBAAkB,GAAG,QAAQ,CAAC;YACvC,OAAO,QAAQ,CAAC;;KACjB;IAED;;;;;;;;;;;;;;;;;;;;;;;;;;OA0BG;IACI,MAAM,CAAO,0BAA0B,CAAC,MAM9C,EAAE,OAA0B;;YAC3B,IAAI,CAAC,eAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;gBACpC,MAAM,IAAI,6BAAoB,CAAC,wCAAwC,CAAC,CAAC;aAC1E;YAED,IAAI,CAAC,IAAA,iBAAS,EAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,IAAA,iBAAS,EAAC,MAAM,CAAC,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,IAAI,CAAC,IAAA,mBAAW,EAAC,MAAM,CAAC,SAAS,CAAC,EAAE;gBACpH,MAAM,IAAI,KAAK,CAAC,8IAA8I,CAAC,CAAC;aACjK;YAED,MAAM,eAAe,GAAG,IAAI,iBAAQ,CAClC,MAAM,CAAC,OAAO,EACd,SAAS,CAAC,SAAS,CAAC,OAAO,CAAC,GAAG,EAC/B,OAAO,CAAC,MAAM,CACf,CAAC;YACF,OAAO,eAAe,CAAC,sBAAsB,CAC3C,MAAM,CAAC,aAAa,EACpB,MAAM,CAAC,IAAI,EACX,MAAM,CAAC,eAAe,EACtB,MAAM,CAAC,SAAS,CACjB,CAAC;QACJ,CAAC;KAAA;IAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;OA4BG;IACI,MAAM,CAAC,2CAA2C,CAAC,MAOzD,EAAE,OAA0B;QAC3B,IAAI,CAAC,eAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;YACpC,MAAM,IAAI,6BAAoB,CAAC,wCAAwC,CAAC,CAAC;SAC1E;QAED,IAAI,CAAC,IAAA,iBAAS,EAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,IAAA,iBAAS,EAAC,MAAM,CAAC,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,IAAI,CAAC,IAAA,mBAAW,EAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,cAAc,IAAI,MAAM,CAAC,cAAc,CAAC,MAAM,KAAK,CAAC,EAAE;YACpL,MAAM,IAAI,KAAK,CAAC,2MAA2M,CAAC,CAAC;SAC9N;QAED,MAAM,eAAe,GAAG,IAAI,iBAAQ,CAClC,MAAM,CAAC,OAAO,EACd,SAAS,CAAC,SAAS,CAAC,OAAO,CAAC,GAAG,EAC/B,OAAO,CAAC,MAAM,CACf,CAAC;QACF,OAAO,eAAe,CAAC,uCAAuC,CAC5D,MAAM,CAAC,aAAa,EACpB,MAAM,CAAC,IAAI,EACX,MAAM,CAAC,cAAc,EACrB,MAAM,CAAC,eAAe,EACtB,MAAM,CAAC,SAAS,CACjB,CAAC;IACJ,CAAC;IAED;;;;;;;;;;;;;;;;;;;OAmBG;IACI,MAAM,CAAO,2BAA2B,CAAC,MAG/C,EAAE,OAA0B;;YAC3B,IAAI,CAAC,eAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;gBACpC,MAAM,IAAI,6BAAoB,CAAC,wCAAwC,CAAC,CAAC;aAC1E;YAED,MAAM,eAAe,GAAG,IAAI,iBAAQ,CAClC,MAAM,CAAC,OAAO,EACd,SAAS,CAAC,SAAS,CAAC,OAAO,CAAC,GAAG,EAC/B,OAAO,CAAC,MAAM,CACf,CAAC;YAEF,OAAO,eAAe,CAAC,uBAAuB,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;QACvE,CAAC;KAAA;IAED;;;;OAIG;IACH,YAAmB,OAAe,EAAE,QAA4B;QAC9D,IAAI,CAAC,OAAO,GAAG,IAAA,sBAAgB,EAAC,OAAO,CAAC,CAAC;QACzC,IAAI,CAAC,mBAAmB,GAAG,SAAS,CAAC;QACrC,IAAI,CAAC,iBAAiB,GAAG,SAAS,CAAC;QACnC,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;IAC3B,CAAC;IAED;;;;;;;;;;OAUG;IACU,QAAQ,CAAC,KAAiB,EAAE,MAAmB,EAAE,MAAc,EAAE,SAAiB,EAAE,IAAY,EAAE,GAAW,EAAE,OAA2B;;;YACrJ,MAAM,OAAO,GAAG,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,MAAM,KAAI,IAAI,CAAC,QAAQ,CAAC;YACjD,IAAI,CAAC,eAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE;gBAC7B,MAAM,IAAI,6BAAoB,CAAC,uCAAuC,CAAC,CAAC;aACzE;YAED,IAAI,CAAC,IAAA,mBAAW,EAAC,SAAS,CAAC,EAAE;gBAC3B,MAAM,IAAI,iBAAiB,CAAC,EAAE,OAAO,EAAE,uCAAuC,EAAE,CAAC,CAAC;aACnF;YACD,MAAM,cAAc,GAAG,IAAA,gBAAQ,EAAC,SAAS,CAAC,CAAC;YAC3C,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,IAAA,mBAAW,EAAC,IAAI,CAAC,EAAE;gBACzC,MAAM,IAAI,iBAAiB,CAAC,EAAE,OAAO,EAAE,kCAAkC,EAAE,CAAC,CAAC;aAC9E;YACD,MAAM,SAAS,GAAG,IAAA,gBAAQ,EAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;YAE1D,IAAI,QAAQ,GAAG,IAAI,CAAC,mBAAmB,CAAC;YACxC,IAAI,CAAC,QAAQ,KAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,MAAM,CAAA,EAAE;gBAChC,QAAQ,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,OAAO,CAAC,CAAC;aACvD;YAED,IAAI,CAAC,CAAA,MAAM,IAAI,CAAC,aAAa,CAAC,IAAA,qBAAa,EAAC,CAAC,SAAS,CAAC,EAAE,CAAC,MAAM,OAAO,CAAC,UAAU,EAAE,CAAC,CAAC,EAAE,0BAAU,CAAC,KAAK,EAAE,OAAO,CAAC,CAAA,EAAE;gBAClH,MAAM,IAAI,gCAAuB,CAAC,EAAE,OAAO,EAAE,oDAAoD,EAAE,CAAC,CAAC;aACtG;YAED,OAAO,QAAQ,CAAC,QAAQ,CAAC,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,cAAc,EAAE,SAAS,EAAE,GAAG,EAAE,MAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,SAAS,mCAAI,EAAE,CAAC,CAAC;;KAC3G;IAED;;;;;;;OAOG;IACU,MAAM,CAAC,GAAW,EAAE,OAAmB,EAAE,IAAa,EAAE,OAA2B;;;YAC9F,MAAM,OAAO,GAAG,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,MAAM,KAAI,IAAI,CAAC,QAAQ,CAAE;YAClD,IAAI,CAAC,eAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE;gBAC7B,MAAM,IAAI,6BAAoB,CAAC,uCAAuC,CAAC,CAAC;aACzE;YAED,IAAI,QAAQ,GAAG,IAAI,CAAC,iBAAiB,CAAC;YACtC,IAAI,CAAC,QAAQ,KAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,MAAM,CAAA,EAAE;gBAChC,QAAQ,GAAG,MAAM,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC;aACrD;YAED,IAAI,CAAC,CAAA,MAAM,IAAI,CAAC,aAAa,CAAC,IAAA,qBAAa,EAAC,CAAC,SAAS,CAAC,EAAE,CAAC,MAAM,OAAO,CAAC,UAAU,EAAE,CAAC,CAAC,EAAE,0BAAU,CAAC,UAAU,EAAE,OAAO,CAAC,CAAA,EAAE;gBACvH,MAAM,IAAI,gCAAuB,CAAC,EAAE,OAAO,EAAE,uDAAuD,EAAE,CAAC,CAAC;aACzG;YAED,IAAG,CAAC,IAAA,mBAAW,EAAC,GAAG,CAAC,EAAE;gBACpB,MAAM,IAAI,eAAe,EAAE,CAAC;aAC7B;YAED,IAAI,MAAM,IAAI,CAAC,aAAa,CAAC,GAAG,EAAE,OAAO,EAAE,OAAO,CAAC,EAAE;gBACnD,MAAM,IAAI,gCAAgC,EAAE,CAAC;aAC9C;YAED,OAAO,QAAQ,CAAC,MAAM,CAAC,GAAG,EAAE,OAAO,EAAE,IAAI,EAAE,MAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,SAAS,mCAAI,EAAE,CAAC,CAAC;;KACtE;IAED;;;;;;;;OAQG;IACU,QAAQ;;YACnB,IAAI,IAAI,CAAC,kBAAkB,EAAE;gBAC3B,MAAM,IAAI,CAAC,kBAAkB,CAAC,QAAQ,EAAE,CAAC;gBAEzC,OAAO,IAAI,CAAC;aACb;YAED,OAAO,IAAI,CAAC;QACd,CAAC;KAAA;IAED;;;;OAIG;IACU,QAAQ,CAAC,OAAe,EAAE,OAA2B;;;YAChE,MAAM,SAAS,GAAG,MAAA,MAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,QAAQ,mCAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,MAAM,mCAAI,IAAI,CAAC,QAAQ,CAAC;YAExE,IAAI,QAAQ,GAAG,IAAI,CAAC,mBAAmB,CAAC;YACxC,IAAI,CAAC,QAAQ,EAAE;gBACb,QAAQ,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,SAAS,CAAC,CAAC;aACzD;YAED,OAAO,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,CAAC,KAAY,EAAE,EAAE;gBACtD,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,kBAAS,CAAC,WAAW,EAAE;oBACtC,OAAO,IAAI,CAAC;iBACb;gBAED,OAAO,IAAI,aAAK,CAAC;oBACf,OAAO,EAAE,IAAI,CAAC,OAAO;oBACrB,EAAE,EAAE,OAAO;oBACX,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,QAAQ,EAAE;oBAC1B,MAAM,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,QAAQ,EAAE;oBAC3B,MAAM,EAAE,KAAK,CAAC,CAAC,CAAC;oBAChB,SAAS,EAAE,KAAK,CAAC,CAAC,CAAC;oBACnB,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;oBACd,GAAG,EAAE,KAAK,CAAC,CAAC,CAAC;iBACd,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;;KACJ;IAED;;;;;OAKG;IACU,SAAS,CAAC,OAAe,EAAE,OAA2B;;YACjE,MAAM,IAAI,KAAK,CAAC,oFAAoF,CAAC,CAAC;QACxG,CAAC;KAAA;IAED;;;;OAIG;IACU,gBAAgB,CAAC,KAA0B,EAAE,OAA2B;;YACnF,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,OAAO,CAAC;iBAC3D,IAAI,CAAC,CAAC,QAAkB,EAAwB,EAAE,CACjD,QAAQ,CAAC,GAAG,CAAC,CAAO,OAAe,EAAsB,EAAE,gDACzD,OAAA,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,OAAO,CAAC,CAAA,GAAA,CAChC,CACF,CAAC;YAEJ,OAAO,OAAO,CAAC,GAAG,CAAY,QAAQ,CAAC,CAAC;QAC1C,CAAC;KAAA;IAED;;;;OAIG;IACU,kBAAkB,CAAC,KAA0B,EAAE,OAA2B;;;YACrF,MAAM,SAAS,GAAG,MAAA,MAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,QAAQ,mCAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,MAAM,mCAAI,IAAI,CAAC,QAAQ,CAAC;YAExE,IAAI,QAAQ,GAAG,IAAI,CAAC,mBAAmB,CAAC;YACxC,IAAI,CAAC,QAAQ,EAAE;gBACb,QAAQ,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,SAAS,CAAC,CAAC;aACzD;YAED,OAAO,QAAQ,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;;KAC3C;IAED;;;;;;;;OAQG;IACI,oBAAoB;QACzB,IAAI,IAAI,CAAC,kBAAkB,EAAE;YAC3B,OAAO,IAAI,CAAC,kBAAkB,CAAC,iBAAiB,CAAC;SAClD;QAED,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;;OAIG;IACU,MAAM,CAAC,GAAW,EAAE,OAA2B;;;YAC1D,MAAM,SAAS,GAAG,MAAA,MAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,QAAQ,mCAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,MAAM,mCAAI,IAAI,CAAC,QAAQ,CAAC;YAExE,IAAI,QAAQ,GAAG,IAAI,CAAC,iBAAiB,CAAC;YACtC,IAAI,CAAC,QAAQ,EAAE;gBACb,QAAQ,GAAG,MAAM,IAAI,CAAC,oBAAoB,CAAC,SAAS,CAAC,CAAC;aACvD;YAED,OAAO,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,GAAqC,EAAE,EAAE;gBACzE,IAAI,GAAG,CAAC,CAAC,CAAC,KAAK,oEAAoE,EAAE;oBACnF,OAAO,IAAI,CAAC;iBACb;gBAED,OAAO;oBACL,QAAQ,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC;oBACnD,IAAI,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,QAAQ,EAAE;oBACvB,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;iBACZ,CAAC;YACJ,CAAC,CAAC,CAAC;;KACJ;IAED;;;;OAIG;IACU,cAAc,CAAC,GAAW,EAAE,OAA2B;;;YAClE,MAAM,SAAS,GAAG,MAAA,MAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,QAAQ,mCAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,MAAM,mCAAI,IAAI,CAAC,QAAQ,CAAC;YAExE,IAAI,QAAQ,GAAG,IAAI,CAAC,iBAAiB,CAAC;YACtC,IAAI,CAAC,QAAQ,EAAE;gBACb,QAAQ,GAAG,MAAM,IAAI,CAAC,oBAAoB,CAAC,SAAS,CAAC,CAAC;aACvD;YAED,OAAO,QAAQ,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,QAAqB,EAAE,EAAE;gBACjE,OAAO,QAAQ,CAAC,GAAG,CAAC,CAAC,OAAkB,EAAE,EAAE,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC,CAAC;YAClE,CAAC,CAAC,CAAC;;KACJ;IAED;;;;OAIG;IACU,gBAAgB,CAAC,OAAmB,EAAE,OAA2B;;;YAC5E,MAAM,SAAS,GAAG,MAAA,MAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,QAAQ,mCAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,MAAM,mCAAI,IAAI,CAAC,QAAQ,CAAC;YAExE,IAAI,QAAQ,GAAG,IAAI,CAAC,iBAAiB,CAAC;YACtC,IAAI,CAAC,QAAQ,EAAE;gBACb,QAAQ,GAAG,MAAM,IAAI,CAAC,oBAAoB,CAAC,SAAS,CAAC,CAAC;aACvD;YAED,MAAM,QAAQ,GAAG,MAAM,QAAQ,CAAC,gBAAgB,CAAC,OAAO,CAAC;iBACtD,IAAI,CAAC,CAAC,IAAc,EAAkB,EAAE;gBACvC,OAAO,IAAI,CAAC,GAAG,CAAC,CAAO,GAAW,EAAgB,EAAE;oBAClD,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;gBACnC,CAAC,CAAA,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;YAEL,OAAO,OAAO,CAAC,GAAG,CAAM,QAAQ,CAAC,CAAC;;KACnC;IAED;;;OAGG;IACU,sBAAsB,CAAC,gBAAoC;;YACtE,MAAM,SAAS,GAAG,gBAAgB,aAAhB,gBAAgB,cAAhB,gBAAgB,GAAI,IAAI,CAAC,QAAQ,CAAC;YAEpD,IAAI,IAAI,CAAC,mBAAmB,IAAI,CAAC,IAAI,CAAC,mBAAmB,CAAC,QAAQ,KAAK,SAAS,IAAI,IAAI,CAAC,mBAAmB,CAAC,MAAM,KAAK,SAAS,CAAC,EAAE;gBAClI,OAAO,IAAI,CAAC,mBAAmB,CAAC;aACjC;YAED,IAAI,CAAC,mBAAmB,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,UAAU,CAAC,OAAO,CAAC,GAAG,EAAE,SAAS,CAAC,CAAC;YAE/F,OAAO,IAAI,CAAC,mBAAmB,CAAC;QAClC,CAAC;KAAA;IAED;;;OAGG;IACU,oBAAoB,CAAC,gBAAoC;;YACpE,MAAM,SAAS,GAAG,gBAAgB,aAAhB,gBAAgB,cAAhB,gBAAgB,GAAI,IAAI,CAAC,QAAQ,CAAC;YAEpD,IAAI,IAAI,CAAC,iBAAiB,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,QAAQ,KAAK,SAAS,IAAI,IAAI,CAAC,iBAAiB,CAAC,MAAM,KAAK,SAAS,CAAC,EAAE;gBAC5H,OAAO,IAAI,CAAC,iBAAiB,CAAC;aAC/B;YAED,IAAI,CAAC,iBAAiB,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,UAAU,CAAC,OAAO,CAAC,GAAG,EAAE,SAAS,CAAC,CAAC;YAE7F,OAAO,IAAI,CAAC,iBAAiB,CAAC;QAChC,CAAC;KAAA;IAED;;;;OAIG;IACU,WAAW,CAAC,GAA0E,EAAE,gBAAoC;;YACvI,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;gBACjB,MAAM,IAAI,KAAK,CAAC,qFAAqF,CAAC,CAAC;aACxG;YAED,MAAM,SAAS,GAAG,gBAAgB,aAAhB,gBAAgB,cAAhB,gBAAgB,GAAI,IAAI,CAAC,QAAQ,CAAC;YAEpD,OAAO,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,OAAO,EAAE,GAAG,EAAE,SAAS,CAAC,CAAC;QACjE,CAAC;KAAA;IAED;;;;;OAKG;IACU,oBAAoB,CAAC,OAAe,EAAE,GAA0E,EAAE,gBAAoC;;YACjK,MAAM,iBAAiB,GAAG,gBAAgB,aAAhB,gBAAgB,cAAhB,gBAAgB,GAAI,IAAI,CAAC,QAAQ,CAAC;YAC5D,IAAI,CAAC,oBAAQ,CAAC,UAAU,CAAC,iBAAiB,CAAC,IAAI,CAAC,eAAM,CAAC,QAAQ,CAAC,iBAAiB,CAAC,EAAE;gBAClF,MAAM,IAAI,6BAAoB,CAAC,+DAA+D,CAAC,CAAC;aACjG;YAED,OAAO,IAAI,iBAAQ,CAAC,OAAO,EAAE,GAAG,EAAE,iBAAiB,CAAC,CAAC;QACvD,CAAC;KAAA;IAED;;;;;OAKG;IACU,aAAa,CAAC,GAAW,EAAE,OAAmB,EAAE,OAA2B;;;YACtF,MAAM,SAAS,GAAG,MAAA,MAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,QAAQ,mCAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,MAAM,mCAAI,IAAI,CAAC,QAAQ,CAAC;YAExE,IAAI,QAAQ,GAAG,IAAI,CAAC,iBAAiB,CAAC;YACtC,IAAI,CAAC,QAAQ,EAAE;gBACb,QAAQ,GAAG,MAAM,IAAI,CAAC,oBAAoB,CAAC,SAAS,CAAC,CAAC;aACvD;YAED,OAAO,QAAQ,CAAC,aAAa,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;;KAC7C;IAED;;;;OAIG;IACU,WAAW,CAAC,OAAe,EAAE,OAA2B;;;YACnE,MAAM,OAAO,GAAG,MAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,MAAM,mCAAI,IAAI,CAAC,QAAQ,CAAC;YACjD,IAAI,CAAC,eAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE;gBAC7B,MAAM,IAAI,6BAAoB,CAAC,uCAAuC,CAAC,CAAC;aACzE;YAED,IAAI,CAAC,CAAA,MAAM,IAAI,CAAC,aAAa,CAAC,IAAA,qBAAa,EAAC,CAAC,SAAS,CAAC,EAAE,CAAC,MAAM,OAAO,CAAC,UAAU,EAAE,CAAC,CAAC,EAAE,0BAAU,CAAC,KAAK,EAAE,OAAO,CAAC,CAAA,EAAE;gBAClH,MAAM,IAAI,gCAAuB,CAAC,EAAE,OAAO,EAAE,uDAAuD,EAAE,CAAC,CAAC;aACzG;YAED,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;YACpD,IAAI,CAAC,KAAK,IAAI,KAAK,CAAC,KAAK,KAAK,CAAC,EAAE;gBAC/B,MAAM,IAAI,qBAAqB,CAAC,EAAE,OAAO,EAAE,uDAAuD,EAAE,CAAC,CAAC;aACvG;YAED,IAAI,QAAQ,GAAG,IAAI,CAAC,mBAAmB,CAAC;YACxC,IAAI,CAAC,QAAQ,KAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,MAAM,CAAA,EAAE;gBAChC,QAAQ,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,OAAO,CAAC,CAAC;aACvD;YAED,OAAO,QAAQ,CAAC,WAAW,CAAC,OAAO,EAAE,MAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,SAAS,mCAAI,EAAE,CAAC,CAAC;;KAChE;IAED;;;;;;OAMG;IACU,SAAS,CAAC,GAAW,EAAE,OAAe,EAAE,OAA2B;;;YAC9E,MAAM,OAAO,GAAG,MAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,MAAM,mCAAI,IAAI,CAAC,QAAQ,CAAC;YACjD,IAAI,CAAC,eAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE;gBAC7B,MAAM,IAAI,6BAAoB,CAAC,uCAAuC,CAAC,CAAC;aACzE;YAED,IAAG,CAAC,IAAA,mBAAW,EAAC,GAAG,CAAC,EAAE;gBACpB,MAAM,IAAI,eAAe,EAAE,CAAC;aAC7B;YAED,IAAI,QAAQ,GAAG,IAAI,CAAC,iBAAiB,CAAC;YACtC,IAAI,CAAC,QAAQ,EAAE;gBACb,QAAQ,GAAG,MAAM,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC;aACrD;YAED,IAAI,CAAC,CAAA,MAAM,IAAI,CAAC,aAAa,CAAC,IAAA,qBAAa,EAAC,CAAC,SAAS,CAAC,EAAE,CAAC,MAAM,OAAO,CAAC,UAAU,EAAE,CAAC,CAAC,EAAE,0BAAU,CAAC,UAAU,EAAE,OAAO,CAAC,CAAA,EAAE;gBACvH,MAAM,IAAI,gCAAuB,CAAC,EAAE,OAAO,EAAE,0DAA0D,EAAE,CAAC,CAAC;aAC5G;YAED,IAAG,CAAC,CAAC,MAAM,IAAI,CAAC,aAAa,CAAC,GAAG,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC,EAAE;gBACrD,MAAM,IAAI,4BAA4B,EAAE,CAAC;aAC1C;YAED,OAAO,QAAQ,CAAC,SAAS,CAAC,GAAG,EAAE,OAAO,EAAE,MAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,SAAS,mCAAI,EAAE,CAAC,CAAC;;KACnE;IAED;;;;OAIG;IACI,WAAW,CAAC,gBAAmC;QACpD,IAAI,CAAC,QAAQ,GAAG,gBAAgB,CAAC;QAEjC,4BAA4B;QAC5B,IAAI,CAAC,mBAAmB,GAAG,SAAS,CAAC;QACrC,IAAI,CAAC,iBAAiB,GAAG,SAAS,CAAC;IACrC,CAAC;IAED;;;;;OAKG;IACU,iBAAiB,CAAC,OAAe,EAAE,SAAiB,EAAE,OAA2B;;YAC5F,IAAI,UAAkB,CAAC;YACvB,IAAI;gBACF,UAAU,GAAG,IAAA,qBAAa,EAAC,OAAO,EAAE,SAAS,CAAC,CAAC;aAChD;YAAC,OAAO,GAAG,EAAE;gBACZ,OAAO,KAAK,CAAC;aACd;YAED,OAAO,MAAM,IAAI,CAAC,aAAa,CAAC,IAAA,qBAAa,EAAC,CAAC,SAAS,CAAC,EAAE,CAAC,UAAU,CAAC,CAAC,EAAE,0BAAU,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;QACxG,CAAC;KAAA;IAED;;;;OAIG;IACU,WAAW,CACtB,KAAmB,EACnB,OAA2B;;;YAE3B,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;gBACjB,OAAO;oBACL,KAAK,EAAE,KAAK;oBACZ,MAAM,EAAE,2BAA2B;iBACpC,CAAC;aACH;YAED,MAAM,SAAS,GAAG,MAAA,MAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,QAAQ,mCAAI,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,MAAM,mCAAI,IAAI,CAAC,QAAQ,CAAC;YACxE,IAAI,CAAC,oBAAQ,CAAC,UAAU,CAAC,SAAS,CAAC,EAAE;gBACnC,MAAM,IAAI,KAAK,CAAC,gDAAgD,CAAC,CAAC;aACnE;YAED,IAAI,SAAc,CAAC;YACnB,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;gBAC7B,SAAS,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;aACjD;iBAAM;gBACL,SAAS,GAAG,KAAK,CAAC;aACnB;YAED,MAAM,MAAM,GAAG,IAAI,aAAK,CAAC,SAAS,CAAC,CAAC;YAEpC,MAAM,KAAK,GAAG,MAAM,MAAM,CAAC,cAAc,CAAC,SAAS,CAAC,CAAC;YAErD,OAAO;gBACL,KAAK;aACN,CAAC;;KACH;CACF;AAtsBD,4BAssBC","sourcesContent":["import { BigNumber, Signer, Contract, constants, ContractFactory } from 'ethers';\nimport { Provider, TransactionResponse } from '@ethersproject/providers';\nimport {\n  arrayify,\n  EventFragment,\n  FunctionFragment,\n  Interface,\n  isAddress,\n  isHexString,\n  verifyMessage,\n  getCreate2Address, keccak256, toUtf8Bytes, concat, defaultAbiCoder,\n} from 'ethers/lib/utils';\nimport * as OnchainID from '@onchain-id/solidity';\n\nimport { ClaimData, ClaimScheme, ClaimTopic } from '../claim/Claim.interface';\nimport { Key, KeyPurpose, KeyType } from './Key.interface';\nimport { IdentityInterface } from './identity.interface';\nimport { normalizeAddress, resolveENS } from '../core/utils/ENS';\nimport { Claim } from '../claim/Claim';\nimport { encodeAndHash } from '../core/utils/Utils';\nimport { InvalidProviderError, OperationForbiddenError } from '../core/errors/Errors';\nimport { BlockchainOptions } from '../core/utils/blockchain-options';\n\nexport class KeyPurposeAlreadyRegisteredError extends Error {\n  public constructor({ message = 'Key already has purpose on identity contract.' }: { message?: string } = {}) {\n    super(message);\n    this.name = 'KeyPurposeAlreadyRegisteredError';\n\n    Object.setPrototypeOf(this, KeyPurposeAlreadyRegisteredError.prototype);\n  }\n}\n\nexport class KeyPurposeNotRegisteredError extends Error {\n  public constructor({ message = 'Key does not have the purpose on identity contract.' }: { message?: string } = {}) {\n    super(message);\n    this.name = 'KeyPurposeNotRegisteredError';\n\n    Object.setPrototypeOf(this, KeyPurposeNotRegisteredError.prototype);\n  }\n}\n\nexport class InvalidKeyError extends Error {\n  public constructor({ message = 'Definition of the Key is not valid.' }: { message?: string } = {}) {\n    super(message);\n    this.name = 'InvalidKeyError';\n\n    Object.setPrototypeOf(this, InvalidKeyError.prototype);\n  }\n}\n\nexport class InvalidClaimError extends Error {\n  public constructor({ message = 'Definition of the Claim is not valid.' }: { message?: string } = {}) {\n    super(message);\n    this.name = 'InvalidClaimError';\n\n    Object.setPrototypeOf(this, InvalidClaimError.prototype);\n  }\n}\n\nexport class NonExistingClaimError extends Error {\n  public constructor({ message = 'There is no such claim.' }: { message?: string } = {}) {\n    super(message);\n    this.name = 'NonExistingClaimError';\n\n    Object.setPrototypeOf(this, NonExistingClaimError.prototype);\n  }\n}\n\nexport class Identity implements IdentityInterface {\n  public keyHolderInstance?: Contract;\n  public claimHolderInstance?: Contract;\n  public address?: string;\n  public provider?: Provider | Signer;\n\n  private deploymentContract?: Contract;\n\n  /**\n   * Instantiate a new Identity with the provided address or ENS string that will be resolved.\n   * @param addressOrENS Must be a valid Ethereum address, checksumed, all lower-case or all uppercase.\n   * @param options\n   * @params options.provider If provided, the identity will use this provider for all blockchain operation (unless override) instead of the SDK default provider.\n   */\n  public static async at(addressOrENS: string, options?: BlockchainOptions): Promise<Identity> {\n    let address: string;\n\n    if (!addressOrENS.includes('.')) {\n      address = normalizeAddress(addressOrENS);\n    } else {\n      if (Provider.isProvider(options?.provider)) {\n        address = await resolveENS(addressOrENS, options?.provider as Provider);\n      } else if (Signer.isSigner(options?.signer) && Provider.isProvider(options?.signer.provider)) {\n        address = await resolveENS(addressOrENS, options?.signer.provider as Provider);\n      } else {\n        throw new InvalidProviderError('Resolving ENS requires a Provider.');\n      }\n    }\n\n    return new Identity(address, options?.signer || options?.provider);\n  }\n\n  /**\n   * Compute the address an ONCHAINID deployed using a Factory/Gateway would have.\n   * @param factory The address of the factory contract (this is not the address of the Gateway contract)\n   * @param unprefixedSalt The salt specified when requesting the deployment, usually the address of the identity owner.\n   * @param implementationAuthority The address of the implementation authority contract used by the Factory.\n   */\n  public static computeDeploymentAddress({ factory, unprefixedSalt, implementationAuthority }: { factory: string; unprefixedSalt: string; implementationAuthority: string }): string {\n    return getCreate2Address(\n      factory,\n      keccak256(\n        toUtf8Bytes('OID' + unprefixedSalt),\n      ),\n      keccak256(\n        concat(\n          [\n            OnchainID.contracts.IdentityProxy.bytecode,\n            defaultAbiCoder.encode(\n              ['address', 'address'],\n              [implementationAuthority, factory],\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  /**\n   * Deploy a new Identity, and return the Identity object.\n   * The signer will pay for the deployment, and will be added in the MANAGEMENT keys.\n   * If not given, the Signer will use the default provider from the SDK if it is defined and is a Signer.\n   * Note that the identity will be returned with the provided Signer, thus management operation can be chained.\n   * @param config - Configuration of the identity to deploy.\n   * @param config.managementKey - Ethereum address to set as the initial management key.\n   * @param config.implementationAuthority - Ethereum address of the implementation authority to use.\n   * @param options\n   * @example Usually called with `identity.deployed()`:\n   * ```typescript\n   * const identity = await Identity.deployNew();\n   * await identity.deployed();\n   * ```\n   */\n  public static async deployNew(config: { managementKey: string; implementationAuthority: string; }, options: BlockchainOptions): Promise<Identity> {\n    if (!Signer.isSigner(options.signer)) {\n      throw new InvalidProviderError('Contract deployment requires a Signer.');\n    }\n\n    if(!isHexString(config.managementKey)) {\n      throw new InvalidKeyError();\n    }\n\n    const contract = await new ContractFactory(OnchainID.contracts.IdentityProxy.abi, OnchainID.contracts.IdentityProxy.bytecode, options?.signer).deploy(\n      config.implementationAuthority,\n      config.managementKey,\n      options?.overrides ?? {},\n    );\n\n    const identity = new Identity(contract.address, options?.signer);\n    identity.deploymentContract = contract;\n    return identity;\n  }\n\n  /**\n   * Deploy a new Identity for a given wallet and a specific salt, and return the Identity object, using an ONCHAINID\n   * Gateway. To deploy an identity using this method, the gatewa requires a signature from an approved signer that\n   * contains the salt and the address of the identity owner (see specifications).\n   * The signer will pay for the deployment.\n   * If not given, the Signer will use the default provider from the SDK if it is defined and is a Signer.\n   * Note that the identity will be returned with the provided Signer, thus management operation can be chained.\n   * @param config - Configuration of the identity to deploy.\n   * @param config.gateway - address of the gateway to use\n   * @param config.identityOwner - address of the identity owner\n   * @param config.salt - address of the factory to deploy a proxy identity.\n   * @param config.signature - signature of salt + identityOwner + expiry (see specifications)\n   * @param config.signatureExpiry - the block timestamp where the signature will expire (in seconds and as a BigNumber)\n   * @param options\n   * @param options.signer - the signer to use to sign and send the transaction\n   * @example Usually called with `identity.deployed()`:\n   * ```typescript\n   * const identity = await Identity.deployUsingGatewayWithSalt({\n   *   gateway: '0x...',\n   *   identityOwner: '0x..',\n   *   salt: 'some-salt',\n   *   signature: '0x...',\n   *   signatureExpiry: BigNumber.from('1689583125'),\n   * });\n   * await identity.deployed();\n   * ```\n   */\n  public static async deployUsingGatewayWithSalt(config: {\n    gateway: string;\n    identityOwner: string;\n    salt: string;\n    signature: string;\n    signatureExpiry: BigNumber;\n  }, options: BlockchainOptions): Promise<TransactionResponse> {\n    if (!Signer.isSigner(options.signer)) {\n      throw new InvalidProviderError('Contract deployment requires a Signer.');\n    }\n\n    if (!isAddress(config.gateway) || !isAddress(config.identityOwner) || !config.salt || !isHexString(config.signature)) {\n      throw new Error('Invalid parameters : gateway and identity owner must be addresses, salt and signature must be hex strings, signatureExpiry must be BigNumber');\n    }\n\n    const gatewayContract = new Contract(\n      config.gateway,\n      OnchainID.contracts.Gateway.abi,\n      options.signer,\n    );\n    return gatewayContract.deployIdentityWithSalt(\n      config.identityOwner,\n      config.salt,\n      config.signatureExpiry,\n      config.signature,\n    );\n  }\n\n  /**\n   * Deploy a new Identity for a given wallet and a specific salt, and return the Identity object, using an ONCHAINID\n   * Gateway. To deploy an identity using this method, the gateway requires a signature from an approved signer that\n   * contains the salt and the address of the identity owner and the list of management keys (see specifications).\n   * The signer will pay for the deployment.\n   * If not given, the Signer will use the default provider from the SDK if it is defined and is a Signer.\n   * Note that the identity will be returned with the provided Signer, thus management operation can be chained.\n   * @param config - Configuration of the identity to deploy.\n   * @param config.gateway - address of the gateway to use\n   * @param config.identityOwner - address of the identity owner\n   * @param config.salt - address of the factory to deploy a proxy identity.\n   * @param config.managementKeys - list of management keys to add to the identity\n   * @param config.signature - signature of salt + identityOwner + expiry (see specifications)\n   * @param config.signatureExpiry - the block timestamp where the signature will expire (in seconds and as a BigNumber)\n   * @param options\n   * @param options.signer - the signer to use to sign and send the transaction\n   * @example Usually called with `identity.deployed()`:\n   * ```typescript\n   * const identity = await Identity.deployUsingGatewayWithSalt({\n   *   gateway: '0x...',\n   *   identityOwner: '0x..',\n   *   salt: 'some-salt',\n   *   managementKeys: [IdentitySDK.utils.encodeAndHash(['address'], ['0x...'])],\n   *   signature: '0x...',\n   *   signatureExpiry: BigNumber.from('1689583125'),\n   * });\n   * await identity.deployed();\n   * ```\n   */\n  public static deployUsingGatewayWithSaltAndManagementKeys(config: {\n    gateway: string;\n    identityOwner: string;\n    salt: string;\n    managementKeys: string[];\n    signature: string;\n    signatureExpiry: BigNumber;\n  }, options: BlockchainOptions): Promise<TransactionResponse> {\n    if (!Signer.isSigner(options.signer)) {\n      throw new InvalidProviderError('Contract deployment requires a Signer.');\n    }\n\n    if (!isAddress(config.gateway) || !isAddress(config.identityOwner) || !config.salt || !isHexString(config.signature) || !config.managementKeys || config.managementKeys.length === 0) {\n      throw new Error('Invalid parameters : gateway and identity owner must be addresses, salt and signature must be hex strings, signatureExpiry must be BigNumber, managementKeys must be an array of hashed managements keys.');\n    }\n\n    const gatewayContract = new Contract(\n      config.gateway,\n      OnchainID.contracts.Gateway.abi,\n      options.signer,\n    );\n    return gatewayContract.deployIdentityWithSaltAndManagementKeys(\n      config.identityOwner,\n      config.salt,\n      config.managementKeys,\n      config.signatureExpiry,\n      config.signature,\n    );\n  }\n\n  /**\n   * Deploy a new Identity, and return the Identity object, using an ONCHAINID Gateway. This method only deploys\n   * an identity for the wallet that signed the transaction.\n   * The signer will pay for the deployment.\n   * If not given, the Signer will use the default provider from the SDK if it is defined and is a Signer.\n   * Note that the identity will be returned with the provided Signer, thus management operation can be chained.\n   * @param config - Configuration of the identity to deploy.\n   * @param config.gateway - address of the gateway to use\n   * @param config.identityOwner - address of the identity owner, must be the address of the signer\n   * @param options\n   * @param options.signer - the signer to use to sign and send the transaction\n   * @example Usually called with `identity.deployed()`:\n   * ```typescript\n   * const identity = await Identity.deployUsingGatewayWithSalt({\n   *   gateway: '0x...',\n   *   identityOwner: '0x..',\n   * });\n   * await identity.deployed();\n   * ```\n   */\n  public static async deployUsingGatewayForWallet(config: {\n    gateway: string;\n    identityOwner: string;\n  }, options: BlockchainOptions): Promise<TransactionResponse> {\n    if (!Signer.isSigner(options.signer)) {\n      throw new InvalidProviderError('Contract deployment requires a Signer.');\n    }\n\n    const gatewayContract = new Contract(\n      config.gateway,\n      OnchainID.contracts.Gateway.abi,\n      options.signer,\n    );\n\n    return gatewayContract.deployIdentityForWallet(config.identityOwner);\n  }\n\n  /**\n   * Instantiate an Identity.\n   * @param address A valid Ethereum address (not an ENS, use `Identity#at(ens)`.).\n   * @param provider Override the default provider of SDK, and use for all operation of this Identity.\n   */\n  public constructor(address: string, provider?: Provider | Signer) {\n    this.address = normalizeAddress(address);\n    this.claimHolderInstance = undefined;\n    this.keyHolderInstance = undefined;\n    this.provider = provider;\n  }\n\n  /**\n   * Add a claim to an Identity.\n   * The signature must have been signed with a keypair having the public key in the CLAIM keys of Identity.\n   * @param topic\n   * @param scheme\n   * @param issuer\n   * @param signature\n   * @param data\n   * @param uri\n   * @param [options]\n   */\n  public async addClaim(topic: ClaimTopic, scheme: ClaimScheme, issuer: string, signature: string, data: string, uri: string, options?: BlockchainOptions): Promise<TransactionResponse> {\n    const _signer = options?.signer || this.provider;\n    if (!Signer.isSigner(_signer)) {\n      throw new InvalidProviderError('Contract operations require a Signer.');\n    }\n\n    if (!isHexString(signature)) {\n      throw new InvalidClaimError({ message: 'signature must be a valid hex string.' });\n    }\n    const signatureBytes = arrayify(signature);\n    if (data.length > 0 && !isHexString(data)) {\n      throw new InvalidClaimError({ message: 'data must be a valid hex string.' });\n    }\n    const dataBytes = arrayify(data.length > 0 ? data : '0x');\n\n    let instance = this.claimHolderInstance;\n    if (!instance || options?.signer) {\n      instance = await this.instantiateClaimHolder(_signer);\n    }\n\n    if (!await this.keyHasPurpose(encodeAndHash(['address'], [await _signer.getAddress()]), KeyPurpose.CLAIM, options)) {\n      throw new OperationForbiddenError({ message: 'CLAIM key required on the identity to add a claim.' });\n    }\n\n    return instance.addClaim(topic, scheme, issuer, signatureBytes, dataBytes, uri, options?.overrides ?? {});\n  }\n\n  /**\n   * Add a Key to an Identity.\n   * The Signer must have a MANAGEMENT key in the Identity.\n   * @param key Must be a valid byte32 hex string (pass the keccak256 hash of the key string encoded (abi.encode)).\n   * @param purpose Must be an integer. It is recommended to use the standard KeyPurpose enum.\n   * @param type Must be a an integer. It is recommended to use the standard KeyType enum.\n   * @param [options]\n   */\n  public async addKey(key: string, purpose: KeyPurpose, type: KeyType, options?: BlockchainOptions): Promise<TransactionResponse> {\n    const _signer = options?.signer || this.provider ;\n    if (!Signer.isSigner(_signer)) {\n      throw new InvalidProviderError('Contract operations require a Signer.');\n    }\n\n    let instance = this.keyHolderInstance;\n    if (!instance || options?.signer) {\n      instance = await this.instantiateKeyHolder(_signer);\n    }\n\n    if (!await this.keyHasPurpose(encodeAndHash(['address'], [await _signer.getAddress()]), KeyPurpose.MANAGEMENT, options)) {\n      throw new OperationForbiddenError({ message: 'MANAGEMENT key required on the identity to add a key.' });\n    }\n\n    if(!isHexString(key)) {\n      throw new InvalidKeyError();\n    }\n\n    if (await this.keyHasPurpose(key, purpose, options)) {\n      throw new KeyPurposeAlreadyRegisteredError();\n    }\n\n    return instance.addKey(key, purpose, type, options?.overrides ?? {});\n  }\n\n  /**\n   * Returns the Identity if the Identity was deployed, or awaits for the Identity to be deployed before returning it.\n   *\n   * @example Usually called after a `Identity.deployNew()`:\n   * ```typescript\n   * const identity = await Identity.deployNew();\n   * await identity.deployed();\n   * ```\n   */\n  public async deployed(): Promise<Identity> {\n    if (this.deploymentContract) {\n      await this.deploymentContract.deployed();\n\n      return this;\n    }\n\n    return this;\n  }\n\n  /**\n   * Get ClaimData details for an Identity.\n   * @param claimId\n   * @param [options]\n   */\n  public async getClaim(claimId: string, options?: BlockchainOptions): Promise<ClaimData> {\n    const _provider = options?.provider ?? options?.signer ?? this.provider;\n\n    let instance = this.claimHolderInstance;\n    if (!instance) {\n      instance = await this.instantiateClaimHolder(_provider);\n    }\n\n    return instance.getClaim(claimId).then((claim: any[]) => {\n      if (claim[2] === constants.AddressZero) {\n        return null;\n      }\n\n      return new Claim({\n        address: this.address,\n        id: claimId,\n        topic: claim[0].toNumber(),\n        scheme: claim[1].toNumber(),\n        issuer: claim[2],\n        signature: claim[3],\n        data: claim[4],\n        uri: claim[5],\n      });\n    });\n  }\n\n  /**\n   * Get claims details for an Identity.\n   * @deprecated\n   * @param claimId\n   * @param [options]\n   */\n  public async getClaims(claimId: string, options?: BlockchainOptions): Promise<ClaimData[]> {\n    throw new Error('Claim retrieval must be performed by exploring ClaimAdded and ClaimRemoved events.');\n  }\n\n  /**\n   * Get Claims details by topic for an Identity.\n   * @param topic\n   * @param [options]\n   */\n  public async getClaimsByTopic(topic: ClaimTopic | number, options?: BlockchainOptions): Promise<ClaimData[]> {\n    const promises = await this.getClaimIdsByTopic(topic, options)\n      .then((claimIds: string[]): Promise<ClaimData>[] =>\n        claimIds.map(async (claimId: string): Promise<ClaimData> =>\n          this.getClaim(claimId, options)\n        ),\n      );\n\n    return Promise.all<ClaimData>(promises);\n  }\n\n  /**\n   * Get ClaimData IDs by topic for an Identity.\n   * @param topic\n   * @param [options]\n   */\n  public async getClaimIdsByTopic(topic: ClaimTopic | number, options?: BlockchainOptions): Promise<string[]> {\n    const _provider = options?.provider ?? options?.signer ?? this.provider;\n\n    let instance = this.claimHolderInstance;\n    if (!instance) {\n      instance = await this.instantiateClaimHolder(_provider);\n    }\n\n    return instance.getClaimIdsByTopic(topic);\n  }\n\n  /**\n   * Returns the deployment transaction of the Identity if it was previously created with Identity.deployNew().\n   *\n   * @example Can be called only after a `Identity.deployNew()`:\n   * ```typescript\n   * const identity = await Identity.deployNew();\n   * identity.getDeployTransaction();\n   * ```\n   */\n  public getDeployTransaction(): TransactionResponse | null {\n    if (this.deploymentContract) {\n      return this.deploymentContract.deployTransaction;\n    }\n\n    return null;\n  }\n\n  /**\n   * Get the details of a key in an Identity.\n   * @param key\n   * @param [options]\n   */\n  public async getKey(key: string, options?: BlockchainOptions): Promise<Key> {\n    const _provider = options?.provider ?? options?.signer ?? this.provider;\n\n    let instance = this.keyHolderInstance;\n    if (!instance) {\n      instance = await this.instantiateKeyHolder(_provider);\n    }\n\n    return instance.getKey(key).then((key: [BigNumber[], BigNumber, string]) => {\n      if (key[2] === '0x0000000000000000000000000000000000000000000000000000000000000000') {\n        return null;\n      }\n\n      return {\n        purposes: key[0].map(purpose => purpose.toNumber()),\n        type: key[1].toNumber(),\n        key: key[2],\n      };\n    });\n  }\n\n  /**\n   * Get the purpose of a key in an identity.\n   * @param key\n   * @param [options]\n   */\n  public async getKeyPurposes(key: string, options?: BlockchainOptions): Promise<KeyPurpose[]> {\n    const _provider = options?.provider ?? options?.signer ?? this.provider;\n\n    let instance = this.keyHolderInstance;\n    if (!instance) {\n      instance = await this.instantiateKeyHolder(_provider);\n    }\n\n    return instance.getKeyPurposes(key).then((purposes: BigNumber[]) => {\n      return purposes.map((purpose: BigNumber) => purpose.toNumber());\n    });\n  }\n\n  /**\n   * Get the details of the keys contained in an Identity by purpose.\n   * @param purpose\n   * @param [options]\n   */\n  public async getKeysByPurpose(purpose: KeyPurpose, options?: BlockchainOptions): Promise<Key[]> {\n    const _provider = options?.provider ?? options?.signer ?? this.provider;\n\n    let instance = this.keyHolderInstance;\n    if (!instance) {\n      instance = await this.instantiateKeyHolder(_provider);\n    }\n\n    const promises = await instance.getKeysByPurpose(purpose)\n      .then((keys: string[]): Promise<Key>[] => {\n        return keys.map(async (key: string): Promise<Key> => {\n          return this.getKey(key, options);\n        });\n      });\n\n    return Promise.all<Key>(promises);\n  }\n\n  /**\n   * Instantiate the Identity IdentityInterface Contract with the Identity's address.\n   * @param [providerOrSigner]\n   */\n  public async instantiateClaimHolder(providerOrSigner?: Provider | Signer): Promise<Contract> {\n    const _provider = providerOrSigner ?? this.provider;\n\n    if (this.claimHolderInstance && (this.claimHolderInstance.provider === _provider || this.claimHolderInstance.signer === _provider)) {\n      return this.claimHolderInstance;\n    }\n\n    this.claimHolderInstance = await this.instantiate(OnchainID.interfaces.IERC735.abi, _provider);\n\n    return this.claimHolderInstance;\n  }\n\n  /**\n   * Instantiate the Identity KeyHolder Contract with the Identity's address.\n   * @param [providerOrSigner]\n   */\n  public async instantiateKeyHolder(providerOrSigner?: Provider | Signer): Promise<Contract> {\n    const _provider = providerOrSigner ?? this.provider;\n\n    if (this.keyHolderInstance && (this.keyHolderInstance.provider === _provider || this.keyHolderInstance.signer === _provider)) {\n      return this.keyHolderInstance;\n    }\n\n    this.keyHolderInstance = await this.instantiate(OnchainID.interfaces.IERC734.abi, _provider);\n\n    return this.keyHolderInstance;\n  }\n\n  /**\n   * Instantiate an Identity with the given abi using the object's address.\n   * @param abi\n   * @param [providerOrSigner]\n   */\n  public async instantiate(abi: Array<string | FunctionFragment | EventFragment> | string | Interface, providerOrSigner?: Provider | Signer): Promise<Contract> {\n    if (!this.address) {\n      throw new Error('Identity has no address defined. Use .instantiateAtAddress() or set .address first.');\n    }\n\n    const _provider = providerOrSigner ?? this.provider;\n\n    return this.instantiateAtAddress(this.address, abi, _provider);\n  }\n\n  /**\n   * Instantiate an Identity with the given abi at a given address.\n   * @param address\n   * @param abi\n   * @param [providerOrSigner]\n   */\n  public async instantiateAtAddress(address: string, abi: Array<string | FunctionFragment | EventFragment> | string | Interface, providerOrSigner?: Provider | Signer): Promise<Contract> {\n    const _providerOrSigner = providerOrSigner ?? this.provider;\n    if (!Provider.isProvider(_providerOrSigner) && !Signer.isSigner(_providerOrSigner)) {\n      throw new InvalidProviderError('A provider or a signer is required to instanciate a contract.');\n    }\n\n    return new Contract(address, abi, _providerOrSigner);\n  }\n\n  /**\n   * Check if a key has at least the given purpose.\n   * @param key\n   * @param purpose\n   * @param [options]\n   */\n  public async keyHasPurpose(key: string, purpose: KeyPurpose, options?: BlockchainOptions): Promise<boolean> {\n    const _provider = options?.provider ?? options?.signer ?? this.provider;\n\n    let instance = this.keyHolderInstance;\n    if (!instance) {\n      instance = await this.instantiateKeyHolder(_provider);\n    }\n\n    return instance.keyHasPurpose(key, purpose);\n  }\n\n  /**\n   * Remove a claim, provided the signer has the right to do so.\n   * @param claimId\n   * @param [options]\n   */\n  public async removeClaim(claimId: string, options?: BlockchainOptions): Promise<TransactionResponse> {\n    const _signer = options?.signer ?? this.provider;\n    if (!Signer.isSigner(_signer)) {\n      throw new InvalidProviderError('Contract operations require a Signer.');\n    }\n\n    if (!await this.keyHasPurpose(encodeAndHash(['address'], [await _signer.getAddress()]), KeyPurpose.CLAIM, options)) {\n      throw new OperationForbiddenError({ message: 'CLAIM key required on the identity to remove a claim.' });\n    }\n\n    const claim = await this.getClaim(claimId, options);\n    if (!claim || claim.topic === 0) {\n      throw new NonExistingClaimError({ message: 'The specified claim ID was not found on the Identity.' });\n    }\n\n    let instance = this.claimHolderInstance;\n    if (!instance || options?.signer) {\n      instance = await this.instantiateClaimHolder(_signer);\n    }\n\n    return instance.removeClaim(claimId, options?.overrides ?? {});\n  }\n\n  /**\n   * Remove a Key from an Identity.\n   * The Signer must have a MANAGEMENT key in the Identity.\n   * @param key Key must be a valid byte32 hex string.\n   * @param purpose KeyPurpose must be a valid byte32 hex string.\n   * @param [options]\n   */\n  public async removeKey(key: string, purpose: number, options?: BlockchainOptions): Promise<TransactionResponse> {\n    const _signer = options?.signer ?? this.provider;\n    if (!Signer.isSigner(_signer)) {\n      throw new InvalidProviderError('Contract operations require a Signer.');\n    }\n\n    if(!isHexString(key)) {\n      throw new InvalidKeyError();\n    }\n\n    let instance = this.keyHolderInstance;\n    if (!instance) {\n      instance = await this.instantiateKeyHolder(_signer);\n    }\n\n    if (!await this.keyHasPurpose(encodeAndHash(['address'], [await _signer.getAddress()]), KeyPurpose.MANAGEMENT, options)) {\n      throw new OperationForbiddenError({ message: 'MANAGEMENT key required on the identity to remove a key.' });\n    }\n\n    if(!(await this.keyHasPurpose(key, purpose, options))) {\n      throw new KeyPurposeNotRegisteredError();\n    }\n\n    return instance.removeKey(key, purpose, options?.overrides ?? {});\n  }\n\n  /**\n   * Use another provider or signer to interact with the Identity.\n   * This will reset all contract instances of the identity that will need to be instantiated once again with the new provider.\n   * @param providerOrSigner\n   */\n  public useProvider(providerOrSigner: Provider | Signer): void {\n    this.provider = providerOrSigner;\n\n    // Reset contract instances.\n    this.claimHolderInstance = undefined;\n    this.keyHolderInstance = undefined;\n  }\n\n  /**\n   * Verify if the message was signed with a key that is authorized to perform action for this Identity.\n   * @param message\n   * @param signature\n   * @param [options]\n   */\n  public async validateSignature(message: string, signature: string, options?: BlockchainOptions): Promise<boolean> {\n    let signingKey: string;\n    try {\n      signingKey = verifyMessage(message, signature);\n    } catch (err) {\n      return false;\n    }\n\n    return await this.keyHasPurpose(encodeAndHash(['address'], [signingKey]), KeyPurpose.ACTION, options);\n  }\n\n  /**\n   * Verify a specific claim given with full data or by ID.\n   * @param claim Claim object or ID.\n   * @param [options]\n   */\n  public async verifyClaim(\n    claim: any | string,\n    options?: BlockchainOptions,\n  ): Promise<{ valid: boolean; reason?: string }> {\n    if (!this.address) {\n      return {\n        valid: false,\n        reason: 'Identity is not deployed.',\n      };\n    }\n\n    const _provider = options?.provider ?? options?.signer ?? this.provider;\n    if (!Provider.isProvider(_provider)) {\n      throw new Error('Provider is required to verify claim validity.');\n    }\n\n    let claimData: any;\n    if (typeof claim === 'string') {\n      claimData = await this.getClaim(claim, options);\n    } else {\n      claimData = claim;\n    }\n\n    const _claim = new Claim(claimData);\n\n    const valid = await _claim.verifyValidity(_provider);\n\n    return {\n      valid,\n    };\n  }\n}\n"]}