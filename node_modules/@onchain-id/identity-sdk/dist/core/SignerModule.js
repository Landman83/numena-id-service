"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignerModule = exports.InvalidSignerModuleParamsError = void 0;
const ethers_1 = require("ethers");
/**
 * Thrown when an invalid address is given
 */
class InvalidSignerModuleParamsError extends Error {
    constructor({ message = 'The provided argument is not a valid Signer.' } = {}) {
        super(message);
        this.name = 'INVALID_SIGNER_MODULE_PARAMS';
        this.message = message;
        Object.setPrototypeOf(this, InvalidSignerModuleParamsError.prototype);
    }
}
exports.InvalidSignerModuleParamsError = InvalidSignerModuleParamsError;
class SignerModule {
    constructor(params) {
        if (!params || typeof params !== 'object') {
            throw new InvalidSignerModuleParamsError({
                message: 'The constructor parameter must be a Signer or must have a signeMessage function and a publicKey property Sor a getPublickKey function.',
            });
        }
        if (ethers_1.Signer.isSigner(params)) {
            this.getPublicKey = () => __awaiter(this, void 0, void 0, function* () {
                return ({
                    key: yield params.getAddress(),
                    type: 'ECDSA',
                    signingMethod: 'ECDSA',
                });
            });
            this.signMessageFunction = (message) => params.signMessage(message);
        }
        else {
            if (params.publicKey && params.getPublicKey) {
                throw new InvalidSignerModuleParamsError({
                    message: 'A SignerModule must define only one of publicKey or getPublicKey.',
                });
            }
            else if (params.publicKey) {
                this.publicKey = params.publicKey;
            }
            else if (params.getPublicKey) {
                this.getPublicKeyFunction = params.getPublicKey;
            }
            else {
                throw new InvalidSignerModuleParamsError({
                    message: 'A SignerModule must define one of publicKey or getPublicKey.',
                });
            }
            if (!params.signMessage) {
                throw new InvalidSignerModuleParamsError({
                    message: 'A SignerModule must define a signMessage function.',
                });
            }
            this.signMessageFunction = params.signMessage;
        }
    }
    static isSignerModule(value) {
        return value.getPublicKey && value.signMessage;
    }
    getPublicKey() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.publicKey) {
                return this.publicKey;
            }
            if (this.getPublicKeyFunction) {
                return this.getPublicKeyFunction();
            }
            throw new Error('Signer has no public key getter.');
        });
    }
    signMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.signMessageFunction(message);
        });
    }
}
exports.SignerModule = SignerModule;
//# sourceMappingURL=SignerModule.js.map