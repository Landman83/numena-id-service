{"version":3,"file":"SignerModule.js","sourceRoot":"","sources":["../../src/core/SignerModule.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,mCAAgC;AAShC;;GAEG;AACH,MAAa,8BAA+B,SAAQ,KAAK;IACvD,YAAmB,EAAE,OAAO,GAAG,8CAA8C,KAAkB,EAAE;QAC/F,KAAK,CAAC,OAAO,CAAC,CAAC;QACf,IAAI,CAAC,IAAI,GAAG,8BAA8B,CAAC;QAC3C,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QAEvB,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,8BAA8B,CAAC,SAAS,CAAC,CAAC;IACxE,CAAC;CACF;AARD,wEAQC;AAUD,MAAa,YAAY;IAKvB,YAAmB,MAAsI;QACvJ,IAAI,CAAC,MAAM,IAAI,OAAO,MAAM,KAAK,QAAQ,EAAE;YACzC,MAAM,IAAI,8BAA8B,CAAC;gBACvC,OAAO,EAAE,wIAAwI;aAClJ,CAAC,CAAC;SACJ;QAED,IAAI,eAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE;YAC3B,IAAI,CAAC,YAAY,GAAG,GAAS,EAAE;gBAAC,OAAA,CAAC;oBAC/B,GAAG,EAAE,MAAM,MAAM,CAAC,UAAU,EAAE;oBAC9B,IAAI,EAAE,OAAO;oBACb,aAAa,EAAE,OAAO;iBACvB,CAAC,CAAA;cAAA,CAAC;YACH,IAAI,CAAC,mBAAmB,GAAG,CAAC,OAA4B,EAAE,EAAE,CAAC,MAAM,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;SAC1F;aAAM;YACL,IAAI,MAAM,CAAC,SAAS,IAAI,MAAM,CAAC,YAAY,EAAE;gBAC3C,MAAM,IAAI,8BAA8B,CAAC;oBACvC,OAAO,EAAE,mEAAmE;iBAC7E,CAAC,CAAC;aACJ;iBAAM,IAAI,MAAM,CAAC,SAAS,EAAE;gBAC3B,IAAI,CAAC,SAAS,GAAG,MAAM,CAAC,SAAS,CAAC;aACnC;iBAAM,IAAI,MAAM,CAAC,YAAY,EAAE;gBAC9B,IAAI,CAAC,oBAAoB,GAAG,MAAM,CAAC,YAAY,CAAC;aACjD;iBAAM;gBACL,MAAM,IAAI,8BAA8B,CAAC;oBACvC,OAAO,EAAE,8DAA8D;iBACxE,CAAC,CAAC;aACJ;YAED,IAAI,CAAC,MAAM,CAAC,WAAW,EAAE;gBACvB,MAAM,IAAI,8BAA8B,CAAC;oBACvC,OAAO,EAAE,oDAAoD;iBAC9D,CAAC,CAAC;aACJ;YACD,IAAI,CAAC,mBAAmB,GAAG,MAAM,CAAC,WAAW,CAAC;SAC/C;IACH,CAAC;IAEM,MAAM,CAAC,cAAc,CAAC,KAAU;QACrC,OAAO,KAAK,CAAC,YAAY,IAAI,KAAK,CAAC,WAAW,CAAC;IACjD,CAAC;IAEY,YAAY;;YACvB,IAAI,IAAI,CAAC,SAAS,EAAE;gBAClB,OAAO,IAAI,CAAC,SAAS,CAAC;aACvB;YAED,IAAI,IAAI,CAAC,oBAAoB,EAAE;gBAC7B,OAAO,IAAI,CAAC,oBAAoB,EAAE,CAAC;aACpC;YAED,MAAM,IAAI,KAAK,CAAC,kCAAkC,CAAC,CAAC;QACtD,CAAC;KAAA;IAEY,WAAW,CAAC,OAAe;;YACtC,OAAO,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,CAAC;QAC3C,CAAC;KAAA;CACF;AA9DD,oCA8DC","sourcesContent":["import { Signer } from 'ethers';\nimport { ErrorParams } from './errors/Errors';\n\nexport interface PublicKey {\n  key: string;\n  type: string;\n  signingMethod: string;\n}\n\n/**\n * Thrown when an invalid address is given\n */\nexport class InvalidSignerModuleParamsError extends Error {\n  public constructor({ message = 'The provided argument is not a valid Signer.' }: ErrorParams = {}) {\n    super(message);\n    this.name = 'INVALID_SIGNER_MODULE_PARAMS';\n    this.message = message;\n\n    Object.setPrototypeOf(this, InvalidSignerModuleParamsError.prototype);\n  }\n}\n\n/**\n * Interface for a signer. This object should be able to sign message and export its public key.\n */\nexport interface SignerModuleInterface {\n  getPublicKey(): Promise<PublicKey>;\n  signMessage(message: Uint8Array | string): Promise<string>;\n}\n\nexport class SignerModule implements SignerModuleInterface {\n  private readonly publicKey?: PublicKey;\n  private readonly getPublicKeyFunction?: () => Promise<PublicKey>;\n  private readonly signMessageFunction: (message: string) => Promise<string>;\n\n  public constructor(params: { publicKey?: PublicKey; getPublicKey?: () => Promise<PublicKey>; signMessage: (message: string) => Promise<string> } | Signer) {\n    if (!params || typeof params !== 'object') {\n      throw new InvalidSignerModuleParamsError({\n        message: 'The constructor parameter must be a Signer or must have a signeMessage function and a publicKey property Sor a getPublickKey function.',\n      });\n    }\n\n    if (Signer.isSigner(params)) {\n      this.getPublicKey = async () => ({\n        key: await params.getAddress(),\n        type: 'ECDSA',\n        signingMethod: 'ECDSA',\n      });\n      this.signMessageFunction = (message: Uint8Array | string) => params.signMessage(message);\n    } else {\n      if (params.publicKey && params.getPublicKey) {\n        throw new InvalidSignerModuleParamsError({\n          message: 'A SignerModule must define only one of publicKey or getPublicKey.',\n        });\n      } else if (params.publicKey) {\n        this.publicKey = params.publicKey;\n      } else if (params.getPublicKey) {\n        this.getPublicKeyFunction = params.getPublicKey;\n      } else {\n        throw new InvalidSignerModuleParamsError({\n          message: 'A SignerModule must define one of publicKey or getPublicKey.',\n        });\n      }\n\n      if (!params.signMessage) {\n        throw new InvalidSignerModuleParamsError({\n          message: 'A SignerModule must define a signMessage function.',\n        });\n      }\n      this.signMessageFunction = params.signMessage;\n    }\n  }\n\n  public static isSignerModule(value: any): value is SignerModuleInterface {\n    return value.getPublicKey && value.signMessage;\n  }\n\n  public async getPublicKey(): Promise<PublicKey> {\n    if (this.publicKey) {\n      return this.publicKey;\n    }\n\n    if (this.getPublicKeyFunction) {\n      return this.getPublicKeyFunction();\n    }\n\n    throw new Error('Signer has no public key getter.');\n  }\n\n  public async signMessage(message: string): Promise<string> {\n    return this.signMessageFunction(message);\n  }\n}\n"]}