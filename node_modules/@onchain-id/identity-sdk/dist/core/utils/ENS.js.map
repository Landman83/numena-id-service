{"version":3,"file":"ENS.js","sourceRoot":"","sources":["../../../src/core/utils/ENS.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,mCAA+B;AAC/B,6CAAsF;AACtF,mCAAmC;AAEnC;;GAEG;AACH,MAAa,mBAAoB,SAAQ,KAAK;IAG5C,YAAmB,EAAE,OAAO,GAAG,oDAAoD,EAAE,KAAK,KAAuB,EAAE;QACjH,KAAK,CAAC,OAAO,CAAC,CAAC;QACf,IAAI,CAAC,IAAI,GAAG,iBAAiB,CAAC;QAC9B,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,OAAO,GAAG,OAAO,IAAI,kDAAkD,CAAC;QAE7E,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,mBAAmB,CAAC,SAAS,CAAC,CAAC;IAC7D,CAAC;CACF;AAXD,kDAWC;AAED;;;;GAIG;AACH,SAAgB,gBAAgB,CAAC,OAAe;IAC9C,IAAI;QACF,OAAO,cAAK,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;KAClC;IAAC,OAAO,GAAG,EAAE;QACZ,MAAM,IAAI,mBAAmB,CAAC,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC,CAAC;KACnD;AACH,CAAC;AAND,4CAMC;AAED;;;;;;;;GAQG;AACH,SAAsB,UAAU,CAAC,GAAW,EAAE,QAA4B;;QACxE,IAAI,CAAC,kBAAS,CAAC,QAAQ,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE;YAC5C,MAAM,IAAI,6BAAoB,CAAC,sGAAsG,CAAC,CAAC;SACxI;QAED,IAAI;YACF,MAAM,OAAO,GAAG,MAAM,QAAQ,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;YAEhD,IAAI,CAAC,OAAO,EAAE;gBACZ,MAAM,IAAI,mBAAmB,CAAC;oBAC5B,OAAO,EAAE,mDAAmD;oBAC5D,KAAK,EAAE,GAAG;iBACX,CAAC,CAAC;aACJ;YAED,OAAO,OAAO,CAAC;SAChB;QAAC,OAAO,GAAG,EAAE;YACZ,MAAM,IAAI,mBAAmB,CAAC;gBAC5B,KAAK,EAAE,GAAG;gBACV,OAAO,EAAE,mDAAmD;aAC7D,CAAC,CAAC;SACJ;IACH,CAAC;CAAA;AAtBD,gCAsBC","sourcesContent":["import { utils } from 'ethers';\nimport { InvalidProviderError, ValueError, ValueErrorParams } from '../errors/Errors';\nimport { providers } from 'ethers';\n\n/**\n * Thrown when an invalid address is given\n */\nexport class InvalidAddressError extends Error implements ValueError {\n  public readonly value: any;\n\n  public constructor({ message = 'Specified address is not a valid Ethereum address.', value }: ValueErrorParams = {}) {\n    super(message);\n    this.name = 'INVALID_ADDRESS';\n    this.value = value;\n    this.message = message || 'Specified value is not a valid Ethereum address.';\n\n    Object.setPrototypeOf(this, InvalidAddressError.prototype);\n  }\n}\n\n/**\n * Check if a string is a valid address (and return it checksummed).\n * @param address\n * @throws InvalidAddressError\n */\nexport function normalizeAddress(address: string): string {\n  try {\n    return utils.getAddress(address);\n  } catch (err) {\n    throw new InvalidAddressError({ value: address });\n  }\n}\n\n/**\n * Resolve a string with the Ethereum Naming Service.\n *\n * It will use the default Provider set for the SDK, or the optional provider in parameters.\n * @param ens\n * @param [provider] Override the default SDK provider.\n * @throws InvalidAddressError If the string could not be resolved to an address.\n * @throws InvalidProviderError If the provider is not a valid provider.\n */\nexport async function resolveENS(ens: string, provider: providers.Provider): Promise<string> {\n  if (!providers.Provider.isProvider(provider)) {\n    throw new InvalidProviderError('Given provider or SDK provider must be a valid Provider to resolve ENS, or a Signer with a provider.');\n  }\n\n  try {\n    const address = await provider.resolveName(ens);\n\n    if (!address) {\n      throw new InvalidAddressError({\n        message: 'ENS does not resolve to a valid Ethereum address.',\n        value: ens,\n      });\n    }\n\n    return address;\n  } catch (err) {\n    throw new InvalidAddressError({\n      value: ens,\n      message: 'Could not resolve the ENS to an ethereum address.',\n    });\n  }\n}\n\n\n"]}